
### 树与二叉树
    注意：二叉树不是树的特殊结构，两者定义不同：二叉树可以为空，树不能为空。且度为2的树跟二叉树也不一样，二叉树要区分左右节点，而树不区分。

    树的定义：树是n个结点的有限集，在任意一棵非空树中：
        1.有且仅有一个特定的称为根的结点
        2.当n＞1时，其余结点可分为m个互不相交的有限集T1,T2,...,Tm，其中每一个集合本身是一棵树，并且称为根的子树

    二叉树定义：二叉树是另一种树型结构，它的特点是每个结点至多只有两棵子树，并且二叉树的子树有左右之分，其次序不能任意颠倒。

        对树来说，结点的子树是不区分左右顺序的，因此度为2的树只能说明树中每个结点的子结点个数不超过2。
        而二叉树虽然也满足每个结点的子结点个数不超过2，当它的左右子树是严格区分的，
        不能随意交换左子树和右子树的位置，这就是二叉树和度为2的树最主要的区别。

### 满二叉树
    定义：一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。
         如果一个二叉树的层数为K，且结点总数是(2^k)-1 ，则它就是满二叉树。

### 完全二叉树
    定义：叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大。

### 二叉查找树
    定义：树中任意节点，其左子树中每个节点的值都小于当前节点，其右子树中节点的值都大于当前节点。

    二叉查找树的查找和插入都非常简单，直接递归遍历即可，但是删除要复杂一些：
        1、要删除的节点没有子节点，则直接将父节点中的指向当前节点的指针置null即可。
        2、要删除的节点只有一个子节点（左子节点或右子节点），更新父节点的指针，指向要删除节点的子节点即可。
        3、要删除的节点有左右两个子节点，则要找到右子树的最小节点或者左子树的最大节点来填补被删除的节点。
    
    二叉树还支持查找最小、最大节点，前驱节点，后继节点；同时，中序遍历可以得到有序的数据序列。
    
    如果二叉查找树中有重复的值，则可以在重复的节点数用数组来存储冲突，
    或者更优雅的做法是插入时将值相同的节点放到其右子树中（把新插入的节点当作大于这个节点的值处理），
    查找时，遇到相等的值并不停止查找，而是继续，直到遇到值相等的叶子节点，删除操作同理。
     
##### 平衡二叉查找树
    定义：二叉树中任意一个节点的左右子树的高度相差不能大于1。（其实，红黑树不是严格定义的平衡二叉查找树，但可以证明其查找插入删除复杂度小于O(2logn)）
         完全二叉树、满二叉树其实都是平衡二叉树（但不一定是可查找的，即有序否），但是非完全二叉树也有可能是平衡二叉树。
         
    1、AVL树
    2、Splay Tree（伸展树）
    3、Treap（堆树）
    4、红黑树：a:根节点是黑色的
             b:每个叶子节点都是黑色的空节点（NIL）（即，叶子节点不存储数据）
             c:任何相邻的节点都不能同时为红色（即，红色节点是被黑色节点隔开的）
             d:每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点（即，拿掉红色节点后，是一个完全m叉树，m<=4）

##### 红黑树
    由2-3树演化而来
    
        
##### 哈希表-二叉查找树对比
     1、哈希表查找、插入、删除都是O(1)，而二叉查找树都是O(logn)，但实际开发中，常量的大小可能不能直接忽略，特别是在n不算特别大的时候。
     2、哈希表中数据是无序存储的，而二叉查找树中序遍历即可。
     3、哈希表扩容耗时较多，所有元素都要重新哈希，且哈希冲突可能会导致性能不稳定。
     4、哈希表的构造需要考虑：哈希函数设计、哈希冲突、扩容、缩容等，平衡二叉查找树则只考虑平衡性即可。
     

### 二叉树遍历
     前序遍历：从根节点开始，先打印当前节点，再打印左子树，最后打印右子树
     中序遍历：从根节点开始，先打印左子树，然后打印当前节点，然后打印右子树
     后续遍历：从根节点开始，先打印左子树，然后打印右子树，最后打印当前节点
     按层遍历：广度优先搜索算法，可以借助队列，先去根节点入队，然后判断队列不为空则取出节点，然后把其左右子节点入队，直到队列为空则遍历完成。
    
     注意：二叉树节点遍历的时间复杂度为O(n)



